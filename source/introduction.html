
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
  
  <!-- Licensed under the Apache 2.0 License -->
  <link rel="stylesheet" type="text/css" href="../_static/fonts/open-sans/stylesheet.css" />
  <!-- Licensed under the SIL Open Font License -->
  <link rel="stylesheet" type="text/css" href="../_static/fonts/source-serif-pro/source-serif-pro.css" />
  <link rel="stylesheet" type="text/css" href="../_static/css/bootstrap.min.css" />
  <link rel="stylesheet" type="text/css" href="../_static/css/bootstrap-theme.min.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
    <title>Introduction &#8212; geomm 0.2.0.dev0 documentation</title>
    <link rel="stylesheet" href="../_static/guzzle.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Installation" href="installation.html" />
    <link rel="prev" title="Geomm: Macromolecular computation routines with numpy and scipy" href="../index.html" />
  
   

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="installation.html" title="Installation"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="../index.html" title="Geomm: Macromolecular computation routines with numpy and scipy"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">geomm 0.2.0.dev0 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="container-wrapper">

      <div id="mobile-toggle">
        <a href="#"><span class="glyphicon glyphicon-align-justify" aria-hidden="true"></span></a>
      </div>
  <div id="left-column">
    <div class="sphinxsidebar">
<div class="sidebar-block">
  <div class="sidebar-wrapper">
    <h2>Contents</h2>
    <div class="sidebar-localtoc">
      <ul>
<li><a class="reference internal" href="#">Introduction</a><ul>
<li><a class="reference internal" href="#features">Features</a></li>
<li><a class="reference internal" href="#getting-started">Getting Started</a></li>
<li><a class="reference internal" href="#motivation-alternatives">Motivation &amp; Alternatives</a></li>
</ul>
</li>
</ul>

    </div>
  </div>
</div>
  <h4>Previous topic</h4>
  <p class="topless"><a href="../index.html"
                        title="previous chapter">Geomm: Macromolecular computation routines with numpy and scipy</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="installation.html"
                        title="next chapter">Installation</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/source/introduction.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div class="sidebar-block">
  <div class="sidebar-wrapper">
    <div id="main-search">
      <form class="form-inline" action="../search.html" method="GET" role="form">
        <div class="input-group">
          <input name="q" type="text" class="form-control" placeholder="Search...">
        </div>
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
      </form>
    </div>
  </div>
</div>
      
    </div>
  </div>
        <div id="right-column">
          
          <div role="navigation" aria-label="breadcrumbs navigation">
            <ol class="breadcrumb">
              <li><a href="../index.html">Docs</a></li>
              
              <li>Introduction</li>
            </ol>
          </div>
          
          <div class="document clearer body">
            
  <div class="section" id="introduction">
<h1>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h1>
<p>The <code class="docutils literal notranslate"><span class="pre">geomm</span></code> library provides a collection of purely functional
computational routines that are especially suited for data related to
large and complex macromolecules such as proteins.</p>
<p><code class="docutils literal notranslate"><span class="pre">geomm</span></code> is <strong>topology agnostic</strong> and instead different sets of atom
indices are used for all computations. The outsourcing of this complex
domain knowledge allows for extreme simplicity and specific focus on
calculating geometric properties with no ambiguity. This also makes
<code class="docutils literal notranslate"><span class="pre">geomm</span></code> only dependent upon standard data structures like the
<code class="docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>.</p>
<div class="section" id="features">
<h2>Features<a class="headerlink" href="#features" title="Permalink to this headline">¶</a></h2>
<p>The feature set is minimal at this point:</p>
<ul class="simple">
<li><p>superimpose structures</p></li>
<li><p>wrangle those periodic boundary conditions</p></li>
<li><p>Cython implementation of Theobald-QCP for fast RMSD calculations</p></li>
</ul>
<p>See the <em>Motivation &amp; Alternatives</em> below for why the <code class="docutils literal notranslate"><span class="pre">geomm</span></code> approach
to software libraries is needed, and we encourage you to add your own
algorithms.</p>
</div>
<div class="section" id="getting-started">
<h2>Getting Started<a class="headerlink" href="#getting-started" title="Permalink to this headline">¶</a></h2>
<p>Once you have the package <a class="reference internal" href="installation.html"><span class="doc">installed</span></a> you can go
straight to the <a class="reference internal" href="reference.html"><span class="doc">API Overview</span></a> or the
<a class="reference internal" href="../api/modules.html"><span class="doc">Full API documentation</span></a>.</p>
<p>There are also a few example to get you started in the <code class="docutils literal notranslate"><span class="pre">info/examples</span></code>
directory.</p>
</div>
<div class="section" id="motivation-alternatives">
<h2>Motivation &amp; Alternatives<a class="headerlink" href="#motivation-alternatives" title="Permalink to this headline">¶</a></h2>
<p>There are many (excellent) packages that provide similar facilities as
<code class="docutils literal notranslate"><span class="pre">geomm</span></code> like:</p>
<ul class="simple">
<li><p><a class="reference external" href="http://mdtraj.org">mdtraj</a></p></li>
<li><p><a class="reference external" href="https://mdanalysis.org">MDAnalysis</a></p></li>
<li><p><a class="reference external" href="http://prody.csb.pitt.edu">ProDy</a></p></li>
<li><p>many others.</p></li>
</ul>
<p>The question then arises “Why another one”?</p>
<p>While these are all excellent packages providing useful functionality
there is a large mismatch between the in-memory representations they
use. This means that integrating them with either with each other or
with your own data means you will need a variety of conversion methods
to go between the different libraries.</p>
<p>This may not be an issue for a small amount of data, but as structures
get larger and the number of data points from simulations becomes larger
then this conversion overhead can become very large.</p>
<p>This is made even worse by the fact that most of the conversions move
through extremely underspecified, slow, and lossy formats like the
Protein Data Bank (PDB) format.</p>
<blockquote>
<div><p>To be clear, we are concerned with computational studies of molecular
models consisting of atoms, bonds, and higher order structures therof
and not on more “realistic” models involving electron densities like
you would have from X-Ray crystallography. The PDB format was
designed for the latter scenario where “topologies” are really just
an afterthought and actually something that is inferred from the 3D
geometries of unconnected atoms. It is tempting to view the PDB
format as simply a CSV-like table format for storing information for
tables of atoms. Unfortunately, it is not this and is highly unsuited
for this task. Furthermore, using a format like PDB which requires a
custom parser (of which there are many) and writer (of which there
are more of) which is unlikely to be either: correct, consistent, and
performant. This is partially due to the fact that inherently the
format itself is not designed to be quickly parsed at all. Thus,
beyond the complexity of mismatches in parsers using PDB as an
interchange format is a bad idea. There are new formats like
<a class="reference external" href="http://mmtf.rcsb.org/">MMTF</a> which are huge step forward in
remediated deficiencies of the PDB format, however, in the end this
format is intended to solve the needs of the crystallography
community <em>and not</em> for all computational macromolecular researchers
at large.</p>
</div></blockquote>
<p>Thus, when using these different packages you must learn the details
about each representation of the molecules. This is unfortunate because
semantically are all essentially equivalent and only differ in details
of syntax and aesthetics.</p>
<p>Furthermore, if you would like to run a series of computations in a
pipeline over a single set of data using N different packages you will
end up having to convert (and likely copy) your data multiple times to
run the subroutines you need.</p>
<p>A better solution to using a different in-memory objects for each
library with attached methods for each object is to use simple pure
functions.</p>
<p>For example, most packages perform computations by first constructing an
object and then running a method inputting some hyperparameters. We will
pick on <code class="docutils literal notranslate"><span class="pre">mdtraj</span></code> since I am most familiar with it but all are equally
guilty.</p>
<p>First we must load from one of the supported formats, usually this is
done from the disk as shown in the example but it is possible to load
once into memory to avoid slow reads and writes to disks:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">mdtraj</span> <span class="k">as</span> <span class="nn">mdj</span>

<span class="c1"># see examples for the structure files</span>
<span class="n">traj</span> <span class="o">=</span> <span class="n">mdj</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;lysozyme_pxylene.pdb&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Once it is loaded into the <code class="docutils literal notranslate"><span class="pre">traj</span></code> object then we can perform
calculations on it with the packages functions, here we calculate the
solvent accessible surface area (SASA) using the Shrake-Rupley
algorithm:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">sasas</span> <span class="o">=</span> <span class="n">mdj</span><span class="o">.</span><span class="n">shrake_rupley</span><span class="p">(</span><span class="n">traj</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that because we have an <code class="docutils literal notranslate"><span class="pre">mdtraj.Trajectory</span></code> object as an argument
there is functionally no difference in this being a method of the
object:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># not actually valid</span>
<span class="n">sasas</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">shrake_rupley</span><span class="p">()</span>
</pre></div>
</div>
<p>Now if we want to find the hydrogen bonds from MDAnalysis we have to
convert again since we cannot use the same representation:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">MDAnalysis</span> <span class="kn">import</span> <span class="n">Universe</span>
<span class="kn">from</span> <span class="nn">MDAnalysis.analysis.hbonds</span> <span class="kn">import</span> <span class="n">HydrogenBondAnalysis</span>


<span class="n">uni</span> <span class="o">=</span> <span class="n">Universe</span><span class="p">(</span><span class="s1">&#39;lysozyme_pxylene.pdb&#39;</span><span class="p">)</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">HydrogenBondAnalysis</span><span class="p">(</span>
    <span class="n">uni</span><span class="p">,</span>
    <span class="s1">&#39;protein&#39;</span><span class="p">,</span>
    <span class="s1">&#39;resname LIG&#39;</span><span class="p">,</span>
    <span class="n">distance</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span>
    <span class="n">angle</span><span class="o">=</span><span class="mf">120.0</span>
<span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p>Notice that both of them take exactly the same information but have
totally different concepts that they are even talking about:
“trajectory” vs. “universe”.</p>
<p>Contrast this with the (not yet implemented) <code class="docutils literal notranslate"><span class="pre">geomm</span></code> version of
shrake-rupley:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">geomm.sasa</span> <span class="kn">import</span> <span class="n">shrake_rupley</span>

<span class="n">sasas</span> <span class="o">=</span> <span class="n">shrake_rupley</span><span class="p">(</span>
    <span class="n">coords</span><span class="p">,</span>
    <span class="n">radii</span><span class="p">,</span>
    <span class="n">probe_radius</span><span class="o">=</span><span class="mf">0.14</span><span class="p">,</span>
    <span class="n">n_sphere_points</span><span class="o">=</span><span class="mi">960</span>
<span class="p">)</span>
</pre></div>
</div>
<p>In this example we just pass in a set of coordinates assumed to be
atoms. For each atom there is an associated radii that you have obtained
by some means. Instead of hiding the magic of looking up the atomic
radii of your atoms we simply make it explicit so that you as the user
have complete control over it. In the <code class="docutils literal notranslate"><span class="pre">mdtraj</span></code> version you must alter
the source files to change the behavior.</p>
<p>Now consider the <code class="docutils literal notranslate"><span class="pre">geomm</span></code> (not yet implemented) version of the hbonds
algorithm:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">geomm.bonds</span> <span class="kn">import</span> <span class="n">hbonds</span>

<span class="n">matches</span><span class="p">,</span> <span class="n">distances</span><span class="p">,</span> <span class="n">angles</span> <span class="o">=</span> <span class="n">hbonds</span><span class="p">(</span>
    <span class="n">coords</span><span class="p">,</span>
    <span class="n">selection_a</span><span class="p">,</span> <span class="c1"># the protein if you wish, or anything else</span>
    <span class="n">selection_b</span><span class="p">,</span> <span class="c1"># the ligand perhaps</span>
    <span class="c1"># the hyperparameters</span>
    <span class="n">distance</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span>
    <span class="n">angle</span><span class="o">=</span><span class="mf">120.0</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<p>No conversions necessary, and you are free to choose whatever sets of
atoms you want to compare. We will adress the drawbacks of the selection
language used in the <code class="docutils literal notranslate"><span class="pre">MDAnalysis</span></code> example below.</p>
<p>In both cases there is really only 3 different pieces of data that are
common to all functions for macromolecules:</p>
<ol class="arabic simple">
<li><p>the 3D atomic coordinates</p></li>
<li><p>the periodic boundary conditions</p></li>
<li><p>the topology (bonds, residues, and types)</p></li>
</ol>
<p>The 3D atomic coordinates and the periodic boundary conditions are
essentially a very well known data structure, the humble array.</p>
<p>The only questions that need to be answered is whether the 3D atomic
coordinates are a single structure (N x 3; N is number of atoms) or a
“trajectory” (M x N x 3; M is the number of frames in the trajectory).
However, these kinds of compositions idealy should be taken care of
special purpose container types (a specialty of computer science). This
is relevant for simulations that don’t follow a linear trajectory model
but rather a branching tree that is used in importance sampling type
simulations such as weighted ensemble (WE) (see
<a class="reference external" href="https://adicksonlab.github.io/wepy">wepy</a>). But also implementors
should be free to customize container types for performance optimization
as well for different platforms, allowing extensions for out-of-memory
access via HDF5 or other streaming data generators. In short the simple
“frame” concept is really the only one that needs any community
consensus anyways and is (amazingly) pretty much already standardized
(i.e. an N x 3 numpy array in the python ecosystem).</p>
<p>As for (non-exotic) periodic boundary conditions there really is only
one lossless format with is a a simple 3 x 3 matrix representing the x,
y, and z unit vectors respectively. Any other representation (such as
box lengths and angles) is easily computable from this and is fully
general (linear algebra FTW).</p>
<p>With that out of the way 2/3 of the format standardization is already
taken care of. This actually covers a large number of useful routines
that you might want to perform. Currently this is all you need to use
<code class="docutils literal notranslate"><span class="pre">geomm</span></code>!!</p>
<p>Actually, <code class="docutils literal notranslate"><span class="pre">geomm</span></code> will always remain <em>sans</em> “topology”. Why? Because,
there is always a version of every computation on molecular structures
that can be expressed in terms of <strong>selections</strong> of the atoms in a given
frame. We saw this in the H-Bonds examples above where we simply
supplied the list of atoms for each countepart in place of ‘protein’ and
‘resname LIG’ used in <code class="docutils literal notranslate"><span class="pre">MDAnalysis</span></code>. As another example, take the
<code class="docutils literal notranslate"><span class="pre">geomm</span></code> <code class="docutils literal notranslate"><span class="pre">superimpose</span></code> function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">superimpose</span><span class="p">(</span><span class="n">ref_coords</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">idxs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
</pre></div>
</div>
<p>Here we only require two 3xN numpy arrays for the reference template,
and the coordinates for which you want to transform (rotate).</p>
<p>Optionally, you can specify the <code class="docutils literal notranslate"><span class="pre">idxs</span></code> (read “indices”) for which you
actually want to minimize RMSD for the rotation matrix of the entire set
of coordinates. Imagine you have a simulation of a receptor protein and
a mobile ligand floating in and around your protein. If you want to see
the differences in the position and orientation of the ligand you really
just want to superimpose the protein structures. To <code class="docutils literal notranslate"><span class="pre">geomm</span></code> the
<code class="docutils literal notranslate"><span class="pre">coords</span></code> are just positions, it has no notion of what a “protein” is.
You supply this notion in terms of the semantics of the operation you
are trying to do, not in the domain language of protein structure.
Imagine <code class="docutils literal notranslate"><span class="pre">geomm</span></code> “guessed” what the protein structure was for you and
there was no way around this? This would be bad. What if you realized
that there is a floppy loop on the protein that makes your alignments
crooked with respect to the binding site. You would have no way of
working around this. What if you just want to use the heavy atoms to
align with.</p>
<p>Many other packages provide domain specific languages (DSLs) to help
address this problem. However, there are many problems with these I will
focus on three.</p>
<p>First of all is incompatibility. I know of at least 3 different
languages for this purpose: VMD, MDtraj, and MDAnalysis. I am sure there
are more. All of them are similar, none are the same semantically.</p>
<p>Second, is the lack of expressiveness and the assumption of complete
domain knowledge. All of these DSLs essentially rely on a small database
that maps keywords like “protein” to a lookup table of matching
keywords. For instance ‘protein’ typically looks at the names of each
residue and decides whether it considers that a protein residue or not.
This works out maybe around 80% of the time, because most residues do
have fairly standard abbreviations. However, many residues have valid
alternative forms such as protonation states (not to mention other
post-translational modifications like disulfide bridges etc.) that may
sometimes be named differently. For instance histidine has many such
forms: HIS, HSD, HSA, etc. From experience I can tell you that no one
lookup table is going to be universal and capture all names produced by
all softwares. And worse they are probably different between each
implementation.</p>
<p>Furthermore, these DSLs don’t cover domain knowledge really outside of
the protein centric world. What about lipid head groups and tails?
Sugars? Disulfide bonds? Ions and solutes? Small molecule functional
groups? They don’t even cover the richness of protein secondary,
tertiary, and quaternary structure. There is no such query language that
can cover all of these domains. I would argue that these restricted
languages actually has an effect on the kinds of questions that
researchers are willing to ask given the limited exressiveness.</p>
<p>Thirdly, is the unfounded implicit assumption on a particular domain
model for macromolecules. To not beat around the bush this means the
prevalent model that <em>all</em> molecules follow the chain, residue, atom
model (with bonds as an afterthought). This is likely due to the use of
the PDB format which has this structure. Despite the concept of a
“reside” coming from the initial discovery of the heterogeneous
polymeric properties of proteins it lives on and even now small
molecules, lipids, sugars, waters, ions, and just about every other
distinct chemical species now having to bear “residue” designations.
This is entirely absurd in practice outside of the context of proteins.
Much more practically should there be concepts of “molecule types” and
some of those molecule types being polymers which can then be expressed
as sequences of residues.</p>
<p>That is the residue is really only a convenient method for indexing
sub-selections of larger structures and as a compression mechanism so
that proteins can be expressed as a simple sequence of abbreviations.
This abbreviation makes a lot of sense in some situations (to say a
geneticist, who is essentially computing residues from DNA sequences)
but not really at all to someone interested in the fine-detail of
molecules that only atoms and bond graphs can give. For our purposes a
“reside” really only is a designation for a set of atoms (i.e. indices
of atoms in the coordinates table).</p>
<p>So in the end the purpose of all these DSLs really is to just allow for
quick selections of subsets of atoms. They do this in a way which is
very easy to get wrong unexpected results and that is restricted only to
the semantics of their small and poorly designed language. In the right
context with proper standardization of domain models, atom names/types,
and residue names/types this might work. However, today the absence of
such standards results only in chaos, we highly recommend against using
these languages, unless necessary or where reproducibility and
correctness don’t matter (for exploratoray analysis perhaps).</p>
<p>A much better approach is to understand the meaning of names in your own
data (and to change them if necessary) and use well established
mechanisms for querying data in deterministic ways. That is the use of
algorithms (for tree and graph traversal like algorithms) and query
languages, similar to SQL.</p>
<p>To this end packages like <code class="docutils literal notranslate"><span class="pre">mdtraj</span></code> do provide methods for generating
standard tables which are either chain, residue, atoms, or bond oriented
with columns relating to entity subsets, positions, and other
characteristics like types and charges.</p>
<p>This is all to say that <code class="docutils literal notranslate"><span class="pre">geomm</span></code> doesn’t want to say anything about
this process and it is up to you to use whatever algorithmic and domain
specific models you need to generate sets of atom indices.</p>
<p>Do I have a solution? No. Many of the failed solutions above are trying
to fix inherently difficult problems about data modelling. Its my
opinion that you should just understand your domain problem very well
and do it yourself. Alternatively, researchers need to actually agree
upon specifications for both ontologies (e.g. what is a residue and what
does it actually apply to) as well as vocabularies (e.g. what are the
canonical names and abbreviations for atoms and residues).</p>
<p>I do have some suggestions for some useful structures that do not
attempt to solve consensus problems above but do provide a collection of
serialization formats to avoid the pain and suffering associated with
PDBs.</p>
<p>First, tables. The table is a massively under-utilized tool in this
field.</p>
<p>You only need a few to remain at feature parity with all of the
ecosystem:</p>
<ul class="simple">
<li><p>molecule/chain table</p></li>
<li><p>residue table</p></li>
<li><p>atom table</p></li>
<li><p>bond table</p></li>
</ul>
<p>The Python <code class="docutils literal notranslate"><span class="pre">pandas</span></code> library has excellent support for reading and
writing to a variety of interchange formats as well as the ability to
query in it’s own way plus standard ones like SQL.</p>
<p>This collection of files (which you could zip into an archive file)
would be the “topology”. For any other level of resolution (say for
protein domains), just add another table. This could easily be adapted
to a standard single-file SQL database like <code class="docutils literal notranslate"><span class="pre">SQlite</span></code>, <code class="docutils literal notranslate"><span class="pre">HDF5</span></code>, or
even pages of an <code class="docutils literal notranslate"><span class="pre">excel</span></code> spreadsheet (shudder).</p>
<p>Another workable alternative is the JSON format used internally in the
<code class="docutils literal notranslate"><span class="pre">mdtraj</span></code> <code class="docutils literal notranslate"><span class="pre">HDF5</span></code> format and in <code class="docutils literal notranslate"><span class="pre">wepy</span></code>. <code class="docutils literal notranslate"><span class="pre">wepy</span></code> provides tools for
reading and writing this format into <code class="docutils literal notranslate"><span class="pre">mdtraj.Topology</span></code> objects, but
JSON parsers are fast and ubiquitous and the resulting dicts-and-lists
datastructure is very easy to manually manipulate.</p>
<p>As for actual numerical data we just defer to the <code class="docutils literal notranslate"><span class="pre">numpy</span></code> ecosystem.
They know what they are doing in terms of arrays of numbers.</p>
<p>The only other thing I can really think of is perhaps a simple FASTA
format for residue sequences. This could be useful for comparative
analysis between different structures.</p>
<p>Thats it! It really isn’t hard once you take a step back and look at the
wreckage thats been continuously piled on for the last few decades. Its
just data, ours isn’t really that special.</p>
<p>I even wrote an example (<code class="docutils literal notranslate"><span class="pre">info/examples/format_conversion</span></code>) that does
all of this starting from, an admittedly well-behaved, PDB starting at
mdtraj.</p>
</div>
</div>


          </div>
            
  <div class="footer-relations">
    
      <div class="pull-left">
        <a class="btn btn-default" href="../index.html" title="previous chapter (use the left arrow)">Geomm: Macromolecular computation routines with numpy and scipy</a>
      </div>
    
      <div class="pull-right">
        <a class="btn btn-default" href="installation.html" title="next chapter (use the right arrow)">Installation</a>
      </div>
    </div>
    <div class="clearer"></div>
  
        </div>
        <div class="clearfix"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="installation.html" title="Installation"
             >next</a> |</li>
        <li class="right" >
          <a href="../index.html" title="Geomm: Macromolecular computation routines with numpy and scipy"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">geomm 0.2.0.dev0 documentation</a> &#187;</li> 
      </ul>
    </div>
<script type="text/javascript">
  $("#mobile-toggle a").click(function () {
    $("#left-column").toggle();
  });
</script>
<script type="text/javascript" src="../_static/js/bootstrap.js"></script>
  <div class="footer">
    &copy; Copyright 2020, Samuel D. Lotz. Created using <a href="http://sphinx.pocoo.org/">Sphinx</a>.
  </div>
  </body>
</html>